package cluster

import (
	"context"
	"fmt"
	"github.com/influxdata/influxdb/query"
	"github.com/influxdata/influxdb/tsdb"
	"github.com/influxdata/influxql"
	"io"
	"math/rand" //added by zk
	"sort"
	"sync"
	"time"

	"go.uber.org/zap"
)

// IteratorCreator is an interface that combines mapping fields and creating iterators.
type IteratorCreator interface {
	query.IteratorCreator
	influxql.FieldMapper
	io.Closer
}

// LocalShardMapper implements a ShardMapper for local shards.
type LocalShardMapper struct {
	MetaClient MetaClient //added by zk
	//MetaClient interface {
	//	ShardGroupsByTimeRange(database, policy string, min, max time.Time) (a []meta11.ShardGroupInfo, err error)
	//}

	TSDBStore interface {
		ShardGroup(ids []uint64) tsdb.ShardGroup
	}
	Timeout time.Duration //added by zk
	Logger  *zap.Logger
}

// MapShards maps the sources to the appropriate shards into an IteratorCreator.
func (e *LocalShardMapper) MapShards(sources influxql.Sources, t influxql.TimeRange, opt query.SelectOptions) (query.ShardGroup, error) {
	a := &LocalShardMapping{
		on:            0,
		mapping:       make(map[string]fd),
		remoteMapping: make(map[influxql.Measurement]fd),
		//f: make(map[string]influxql.DataType),
		//d: make(map[string]struct{}),
		Ics: make([]*remoteIteratorCreator, 0),
	}

	tmin := time.Unix(0, t.MinTimeNano())
	tmax := time.Unix(0, t.MaxTimeNano())
	if err := e.mapShards(a, sources, tmin, tmax); err != nil {
		return nil, err
	}
	a.MinTime, a.MaxTime = tmin, tmax
	return a, nil
}
func (e *LocalShardMapper) walk(sources influxql.Sources, ret *influxql.Sources) error {
	for _, s := range sources {
		switch s := s.(type) {
		case *influxql.Measurement:
			*ret = append(*ret, s)
		case *influxql.SubQuery:
			if err := e.walk(s.Statement.Sources, ret); err != nil {
				return err
			}
		}
	}
	return nil
}

// modified by zk
func (e *LocalShardMapper) mapShards(a *LocalShardMapping, sources influxql.Sources, tmin, tmax time.Time) error {
	sources_ := make(influxql.Sources, 0, len(sources))
	errr := e.walk(sources, &sources_)
	if errr != nil {
		return errr
	}
	// Retrieve a list of shard IDs.
	shards, err := e.MetaClient.ShardsByTimeRange(influxql.Sources(sources_), tmin, tmax)
	if err != nil {
		return err
	}

	// Map shards to nodes.
	shardIDsByNodeID := make(map[uint64][]uint64)
	for _, si := range shards {
		// Always assign to local node if it has the shard.
		// Otherwise randomly select a remote node.
		var nodeID uint64
		if len(si.Owners) > 0 {
			nodeID = si.Owners[rand.Intn(len(si.Owners))].NodeID
			node, err := e.MetaClient.DataNode(nodeID)
			if err != nil {
				return err
			}
			if node.Active == false {
				for _, id := range si.Owners {
					node, err = e.MetaClient.DataNode(id.NodeID)
					if err != nil {
						return err
					}
					if node.Active == true {
						nodeID = id.NodeID
						break
					}
				}
				if node.Active != true {
					e.Logger.Error(fmt.Sprintf("Shard %d does not have a valid data node", si.ID))
					continue
				}
			}
		} else {
			// This should not occur but if the shard has no owners then
			// we don't want this to panic by trying to randomly select a node.
			continue
		}

		// Otherwise assign it to a remote shard randomly.
		shardIDsByNodeID[nodeID] = append(shardIDsByNodeID[nodeID], si.ID)
	}
	for nodeID, shardIDs := range shardIDsByNodeID {
		// Sort shard IDs so we get more predicable execution.
		sort.Sort(uint64Slice(shardIDs))

		// Create iterator creators from TSDB if local.
		// Otherwise create iterator creator remotely.
		dialer := &NodeDialer{
			MetaClient: e.MetaClient,
			Timeout:    e.Timeout,
		}
		a.Ics = append(a.Ics, newRemoteIteratorCreator(dialer, nodeID, shardIDs)) //外地
	}

	return nil

}

// ShardMapper maps data sources to a list of shard information.
type fd struct {
	F map[string]influxql.DataType
	D map[string]struct{}
}

type LocalShardMapping struct {
	Ics           []*remoteIteratorCreator
	on            int
	mapping       map[string]fd
	remoteMapping map[influxql.Measurement]fd
	// MinTime is the minimum time that this shard mapper will allow.
	// Any attempt to use a time before this one will automatically result in using
	// this time instead.
	MinTime time.Time

	// MaxTime is the maximum time that this shard mapper will allow.
	// Any attempt to use a time after this one will automatically result in using
	// this time instead.
	MaxTime time.Time
}

func (a *LocalShardMapping) Switch() {
	a.on = 0
}

func (a *LocalShardMapping) FieldDimensions(m *influxql.Measurement) (fields map[string]influxql.DataType, dimensions map[string]struct{}, err error) {
	fields = make(map[string]influxql.DataType)
	dimensions = make(map[string]struct{})
	fd := a.mapping[m.String()]
	for k, typ := range fd.F {
		fields[k] = typ
	}
	for k := range fd.D {
		dimensions[k] = struct{}{}
	}
	return
}

func (a *LocalShardMapping) FieldDimensions1(sources influxql.Sources) (fields map[string]influxql.DataType, dimensions map[string]struct{}, err error) {
	if a.on <= 0 {
		for _, ic := range a.Ics {
			mapping, err := ic.FieldDimensions(sources)
			if err != nil {
				return nil, nil, err
			}
			for m, fd := range mapping {
				key := m.String()
				_, ok := a.mapping[key]
				if !ok {
					a.mapping[key] = fd
				} else {
					for k, typ := range fd.F {
						if a.mapping[key].F[k].LessThan(typ) { //fixed by zk
							a.mapping[key].F[k] = typ
						}
					}
					for k := range fd.D {
						a.mapping[key].D[k] = struct{}{}
					}
				}
			}
		}

		fields = make(map[string]influxql.DataType)
		dimensions = make(map[string]struct{})
		for _, fd := range a.mapping {
			for k, typ := range fd.F {
				fields[k] = typ
			}
			for k := range fd.D {
				dimensions[k] = struct{}{}
			}
		}
		a.on = 3
	} else if a.on == 1 {
		for _, ic := range a.Ics {
			mapping, err := ic.FieldType(a.remoteMapping)
			if err != nil {
				return nil, nil, err
			}
			for m, fd := range mapping {
				key := m.String()
				_, ok := a.mapping[key]
				if !ok {
					a.mapping[key] = fd
				} else {
					for k, typ := range fd.F {
						if a.mapping[key].F[k].LessThan(typ) {
							a.mapping[key].F[k] = typ
						} else {
						}
					}
					for k := range fd.D {
						a.mapping[key].F[k] = influxql.Tag
					}
				}
			}
		}
		a.on = 2
	}

	return
}

func (a *LocalShardMapping) MapType(m *influxql.Measurement, field string) influxql.DataType {
	if a.on == 0 {
		a.on = 1
		if m.SystemIterator != "" {
			return -1
		}
	}

	if m.SystemIterator != "" {
		switch field {
		case "_name", "_tagKey", "_tagValue", "_seriesKey":
			return influxql.String
		}

		// Process system measurements.
		switch m.SystemIterator {
		case "_fieldKeys":
			if field == "fieldKey" || field == "fieldType" {
				return influxql.String
			}
			return influxql.Unknown
		case "_series":
			if field == "key" {
				return influxql.String
			}
			return influxql.Unknown
		case "_tagKeys":
			if field == "tagKey" {
				return influxql.String
			}
			return influxql.Unknown
		}
	}

	var ret influxql.DataType
	ret = -1
	key := m.String()
	fd, ok := a.mapping[key]
	if a.on == 1 {
		if !ok {
			fd.F = make(map[string]influxql.DataType)
			fd.D = make(map[string]struct{})
			a.mapping[key] = fd
			a.remoteMapping[*m] = fd
		}
		fd.F[field] = influxql.Unknown
	} else if ok && a.on == 2 {
		ret, ok = fd.F[field]
	} else if ok && a.on == 3 {
		ret, ok = fd.F[field]
		if !ok {
			_, ok = fd.D[field]
			if ok {
				ret = influxql.Tag
			}
		}
	}
	return ret
}

func (a *LocalShardMapping) CreateIterator(ctx context.Context, m *influxql.Measurement, opt query.IteratorOptions) (query.Iterator, error) {
	inputs := make([]query.Iterator, 0, len(a.Ics))

	var wg sync.WaitGroup
	iterCs := make(chan interface{}, len(a.Ics))

	for _, ic := range a.Ics {
		wg.Add(1)
		go func(ic *remoteIteratorCreator) {
			input, err := ic.CreateIterator(ctx, m, opt)
			if err != nil {
				iterCs <- err
			} else {
				iterCs <- input
			}
			//a.Logger.Debug(fmt.Sprintf("ack is received | ic:%v | input: %v | err: %v", ic, input, err))
			wg.Done()
		}(ic)
	}

	wg.Wait()

	for i := 0; i < len(a.Ics); i++ {
		tmp := <-iterCs
		err, ok := tmp.(error)
		if ok {
			query.Iterators(inputs).Close()
			//fmt.Println("errrrrrror", err)
			return nil, err
		}
		input, ok := tmp.(query.Iterator)
		if ok {
			inputs = append(inputs, input)
		} else {
			fmt.Println("why is nil? may be tag")
		}
	}

	input, err := query.Iterators(inputs).Merge(opt)
	if err != nil {
		query.Iterators(inputs).Close()
		return nil, err
	}
	return input, nil
}

func (a *LocalShardMapping) IteratorCost(m *influxql.Measurement, opt query.IteratorOptions) (query.IteratorCost, error) {
	//source := Source{
	//	Database:        m.Database,
	//	RetentionPolicy: m.RetentionPolicy,
	//}

	//sg := a.ShardMap[source]
	//if sg == nil {
	return query.IteratorCost{}, nil
	//}

	//// Override the time constraints if they don't match each other.
	//if !a.MinTime.IsZero() && opt.StartTime < a.MinTime.UnixNano() {
	//	opt.StartTime = a.MinTime.UnixNano()
	//}
	//if !a.MaxTime.IsZero() && opt.EndTime > a.MaxTime.UnixNano() {
	//	opt.EndTime = a.MaxTime.UnixNano()
	//}

	//if m.Regex != nil {
	//	var costs query.IteratorCost
	//	measurements := sg.MeasurementsByRegex(m.Regex.Val)
	//	for _, measurement := range measurements {
	//		cost, err := sg.IteratorCost(measurement, opt)
	//		if err != nil {
	//			return query.IteratorCost{}, err
	//		}
	//		costs = costs.Combine(cost)
	//	}
	//	return costs, nil
	//}
	//return sg.IteratorCost(m.Name, opt)
}

// Close clears out the list of mapped shards.
func (a *LocalShardMapping) Close() error {
	a.Ics = nil
	return nil
}

// Source contains the database and retention policy source for data.
type Source struct {
	Database        string
	RetentionPolicy string
}
