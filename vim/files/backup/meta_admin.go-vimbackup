package main

import (
	"errors"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"os/signal"
	"strconv"
	"strings"
	"syscall"
	"time"

	meta "github.com/influxdata/influxdb/cluster/meta11"
	"github.com/influxdata/influxdb/services/rebalance"
	"github.com/peterh/liner"
)

var ErrBlankCommand = errors.New("empty input")
var ErrLessArguments = errors.New("less arguments for this command")
var QuitCommand = errors.New("quit")

func formatTimeWithLocation(t time.Time) string {
	l, e := time.LoadLocation("Asia/Shanghai")
	if e != nil {
		return t.Format("2006-01-02 15:04:05")
	} else {
		return t.In(l).Format("2006-01-02 15:04:05")
	}
}

func usage() {
	fmt.Printf("Usage: ./meta_admin\n\t--meta-server [address,address...]\n\t--meta-user [meta user name]\n\t--meta-password [meta password]\n\t--help\n")
}

func command() {
	fmt.Printf("=========the following commands may just change meta data=======\n")
	fmt.Printf("[add-meta-node] [httpaddr,tcpaddr]\n")
	fmt.Printf("[remove-meta-node] [ID]\n")
	fmt.Printf("[add-data-node] [httpaddr,tcpaddr]\n")
	fmt.Printf("[add-data-node-with-id] [httpaddr,tcpaddr,datanode-id]\n")
	fmt.Printf("[remove-data-node] [ID]\n")
	fmt.Printf("[show-metadata]\n")
	fmt.Printf("[show-database] [database-name]\n")
	fmt.Printf("[truncate-hot-shards]\n")
	//fmt.Printf("[add-shard-owner] [shardID] [ownerID] (just for dev test)")
	//fmt.Printf("[remove-shard-owner] [shardID] [ownerID] (just for dev test)")
	fmt.Printf("\n====the following commands may change meta data & user nodes====\n")
	fmt.Printf("[copy-shard] [source_NodeID] [destination_NodeID] [shardID]\n")
	fmt.Printf("[move-shard] [source_NodeID] [destination_NodeID] [shardID]\n")
	fmt.Printf("[mirror-all-shards] [oldNodeID] [newNodeID] (will copy all shards on oldNode to newNode even when oldNode is INACTIVE)\n")
	//fmt.Printf("[reclaim-shards] [nodeID]\n")
	fmt.Printf("[copy-all-cold-shards-to] [source_NodeID] [destination_Node] (will copy all shards on oldNode to newNode if sourceNode is ACTIVE)\n")
	fmt.Printf("[drop-shard-on] [shardID] [ownerID]\n")
	fmt.Printf("\n====================other commands==============================\n")
	fmt.Printf("[show-command]\n")
	fmt.Printf("[exit, quit, q]\n")
}

func isAvailableNode(username, password string, nodeHost string) (bool, string) {
	rt := false
	errMsg := ""

	authInfo := ""
	if username != "" {
		authInfo = username + ":" + password + "@"
	}

	url := fmt.Sprintf("http://%s%s/ping", authInfo, nodeHost)
	resp, err := http.Get(url)
	if err == nil {
		if resp.StatusCode == http.StatusOK {
			_, err := ioutil.ReadAll(resp.Body)
			if err == nil {
				rt = true
			} else {
				errMsg = "failed to ping"
			}
		}
		resp.Body.Close()
	} else {
		errMsg = err.Error()
	}

	return rt, errMsg
}

func showmetadata(metaData *meta.Data, client *meta.Client, username, password string) {
	fmt.Printf("Term:       %d\n", metaData.Term)
	fmt.Printf("Index:      %d\n", metaData.Index)
	fmt.Printf("ClusterID:  %d\n", metaData.ClusterID)
	fmt.Printf("MaxNodeID:  %d\n", metaData.MaxNodeID)
	fmt.Printf("MaxShardID: %d\n", metaData.MaxShardID)
	fmt.Printf("MaxShardGroupID: %d\n", metaData.MaxShardGroupID)

	leader := client.GetMetaLeader()
	fmt.Printf("MetaNodes: \n")
	for _, node := range metaData.MetaNodes {
		isLeader := ""
		if leader == node.TCPHost {
			isLeader = "leader"
		} else {
			isLeader = "offline"
			authInfo := ""
			if username != "" {
				authInfo = username + ":" + password + "@"
			}
			url := fmt.Sprintf("http://%s%s/ping", authInfo, node.Host)
			resp, err := http.Get(url)
			if err == nil {
				if resp.StatusCode == http.StatusOK {
					b, err := ioutil.ReadAll(resp.Body)
					resp.Body.Close()
					if err == nil &&
						len(b) > 0 {
						isLeader = "online"
					}
				}
			}
		}

		fmt.Printf("\t%d\t%s\t%s\t%s\n",
			node.ID,
			node.Host,
			node.TCPHost,
			isLeader)
	}

	fmt.Printf("DataNodes: \n")
	for _, node := range metaData.DataNodes {
		tm := time.Unix(node.ActiveTime, 0)
		fmt.Printf("\t%d\t%s\t%s\t", node.ID, node.Host, node.TCPHost)
		if node.Active {
			fmt.Printf("active\t")
		} else {
			fmt.Printf("inactive\t")
		}
		fmt.Println(formatTimeWithLocation(tm))
	}

	fmt.Printf("UserInfo: \n")
	for _, user := range metaData.Users {
		fmt.Printf("\t%s\n", user.Name)
	}

	fmt.Printf("--------------------------------------------\n")

	fmt.Printf("Database: \n")
	for _, database := range metaData.Databases {
		fmt.Printf("\t%s\n", database.Name)
	}
}

func showdatabase(metaData *meta.Data, name string) {
	for _, database := range metaData.Databases {
		if database.Name != name {
			continue
		}

		fmt.Printf("DataBase: %s\n", database.Name)
		for _, rp := range database.RetentionPolicies {
			fmt.Printf("\tRetentionPoliciy: %s\n", rp.Name)
			for i := len(rp.ShardGroups) - 1; i >= 0; i-- {
				sg := rp.ShardGroups[i]
				deleted := "existing"
				if sg.Deleted() {
					deleted = "deleted"
				}
				fmt.Printf("\t\tShardGroup: %d, %s, %s, %s\n",
					sg.ID,
					formatTimeWithLocation(sg.StartTime),
					formatTimeWithLocation(sg.EndTime),
					deleted)
				if sg.Deleted() {
					continue
				}
				for _, s := range sg.Shards {
					fmt.Printf("\t\t\tShard: %d, nodes: ", s.ID)
					for _, so := range s.Owners {
						fmt.Printf("%d ", so.NodeID)
					}
					fmt.Printf("\n")
				}
			}
		}
	}
}

func copyShard(client *meta.Client, sourceNodeID, destinationNodeID, shardID uint64, delete_shard_after_copy bool) error {
	if sourceNodeID == destinationNodeID {
		fmt.Printf("cant not copy shard on the same node\n")
		return nil
	}

	sNode, _ := client.DataNode(sourceNodeID)
	dNode, _ := client.DataNode(destinationNodeID)

	if sNode == nil {
		fmt.Printf("Failed, cant not find Node %d in cluster\n", sourceNodeID)
		return nil
	}

	if dNode == nil {
		fmt.Printf("Failed, cant not find Node %d in cluster\n", destinationNodeID)
		return nil
	}

	rebCli := rebalance.NewClient(sNode.TCPHost)
	if delete_shard_after_copy == true {
		rep, err := rebCli.SendMoveShardRequest(shardID, dNode.TCPHost)
		if err != nil {
			return err
		} else {
			fmt.Println(rep.Message)
		}
	} else {
		rep, err := rebCli.SendCopyShardRequest(shardID, dNode.TCPHost)
		if err != nil {
			return err
		} else {
			fmt.Println(rep.Message)
		}
	}
	return nil
}

func copyAllColdShards(client *meta.Client, sourceNodeID, destinationNodeID uint64, delete_shards_after_copy bool) error {
	if sourceNodeID == destinationNodeID {
		fmt.Printf("cant not copy shard on the same node\n")
		return nil
	}

	sNode, _ := client.DataNode(sourceNodeID)
	dNode, _ := client.DataNode(destinationNodeID)

	if sNode == nil {
		fmt.Printf("Failed, cant not find Node %d in cluster\n", sourceNodeID)
		return nil
	}

	if dNode == nil {
		fmt.Printf("Failed, cant not find Node %d in cluster\n", destinationNodeID)
		return nil
	}

	rebCli := rebalance.NewClient(sNode.TCPHost)
	if delete_shards_after_copy == false {
		rep, err := rebCli.SendMigrateShardRequest(dNode.TCPHost)
		if err != nil {
			return err
		} else {
			fmt.Println(rep.Message)
		}
	}
	return nil
}

func pullShards(client *meta.Client, nodeID uint64) error {
	node, _ := client.DataNode(nodeID)
	if node == nil {
		fmt.Printf("Failed, cant not find Node %d in cluster\n", nodeID)
		return nil
	}
	rebCli := rebalance.NewClient(node.TCPHost)
	rep, err := rebCli.SendPullShardRequest()
	if err != nil {
		return err
	} else {
		fmt.Println(rep.Message)
	}
	return nil
}

func exit() error {
	return QuitCommand
}

func parseCommand(command_line string, client *meta.Client, username, password string) error {
	command_line = strings.Trim(command_line, " ")
	token := strings.Split(command_line, " ")
	if len(token) >= 1 {
		switch token[0] {
		case "add-meta-node":
			if len(token) < 2 {
				return ErrLessArguments
			}
			addr := strings.Split(token[1], ",")
			if len(addr) < 2 {
				return ErrLessArguments
			}

			rt, errMsg := isAvailableNode(username, password, addr[0])
			if !rt {
				fmt.Printf("Node is invalid:%s\n", errMsg)
			} else {
				_, err := client.JoinMetaServer(addr[0], addr[1])
				if err != nil {
					fmt.Printf("Failed: %v\n", err.Error())
				} else {
					fmt.Printf("Success.\n")
				}
			}
		case "remove-meta-node":
			if len(token) < 2 {
				return ErrLessArguments
			}
			id, err := strconv.ParseUint(token[1], 10, 64)
			if err != nil {
				fmt.Printf("Invalid ID.\n")
			} else {
				err = client.DeleteMetaNode(id)
				if err != nil {
					fmt.Printf("Failed.\n")
				} else {
					fmt.Printf("Success.\n")
				}
			}
		case "add-data-node":
			if len(token) < 2 {
				return ErrLessArguments
			}
			addr := strings.Split(token[1], ",")
			if len(addr) < 2 {
				return ErrLessArguments
			}
			_, err := client.CreateDataNode(addr[0], addr[1], 0)
			if err != nil {
				fmt.Printf("Failed, %s.\n", err.Error())
			} else {
				fmt.Printf("Success.\n")
			}
		case "add-data-node-with-id":
			if len(token) < 2 {
				return ErrLessArguments
			}
			param := strings.Split(token[1], ",")
			if len(param) < 2 {
				return ErrLessArguments
			}
			id, _ := strconv.ParseUint(param[2], 10, 64)
			_, err := client.CreateDataNode(param[0], param[1], id)
			if err != nil {
				fmt.Printf("Failed, %s.\n", err.Error())
			} else {
				fmt.Printf("Success.\n")
			}
		case "remove-data-node":
			if len(token) < 2 {
				return ErrLessArguments
			}
			id, err := strconv.ParseUint(token[1], 10, 64)
			if err != nil {
				fmt.Printf("Invalid ID.\n")
			} else {
				err = client.DeleteDataNode(id)
				if err != nil {
					fmt.Printf("Failed: %s\n", err.Error())
				} else {
					fmt.Printf("Success.\n")
				}
			}
		case "create-database":
			if len(token) < 2 {
				return ErrLessArguments
			}
			_, err := client.CreateDatabase(token[1])
			if err != nil {
				fmt.Printf("Failed, %s\n", err.Error())
			} else {
				fmt.Printf("Success.\n")
			}
		case "create-retention-policy":
			if len(token) < 3 {
				return ErrLessArguments
			}
			_, err := client.CreateRetentionPolicy(token[1], meta.NewRetentionPolicyInfo(token[2]))
			if err != nil {
				fmt.Printf("Failed, %s\n", err.Error())
			} else {
				fmt.Printf("Success.\n")
			}
		case "create-shardgroup":
			if len(token) < 3 {
				return ErrLessArguments
			}
			_, err := client.CreateShardGroup(token[1], token[2], time.Now())
			if err != nil {
				fmt.Printf("Failed, %s.\n", err.Error())
			} else {
				fmt.Printf("Success.\n")
			}
		case "show-metadata":
			metaData := client.Data()
			showmetadata(metaData, client, username, password)
		case "show-database":
			if len(token) < 2 {
				return ErrLessArguments
			}
			metaData := client.Data()
			showdatabase(metaData, token[1])
		case "truncate-hot-shards":
			err := client.SplitHotShardGroup()
			if err != nil {
				fmt.Printf("failed, reason:%s\n", err.Error())
			}
			fmt.Printf("Success.\n")
		case "copy-shard":
			if len(token) < 4 {
				return ErrLessArguments
			}
			sourceNodeID, _ := strconv.ParseUint(token[1], 10, 64)
			destinationNodeID, _ := strconv.ParseUint(token[2], 10, 64)
			shardID, _ := strconv.ParseUint(token[3], 10, 64)

			return copyShard(client, sourceNodeID, destinationNodeID, shardID, false)
		case "move-shard":
			if len(token) < 4 {
				return ErrLessArguments
			}
			sourceNodeID, _ := strconv.ParseUint(token[1], 10, 64)
			destinationNodeID, _ := strconv.ParseUint(token[2], 10, 64)
			shardID, _ := strconv.ParseUint(token[3], 10, 64)
			// move shard
			return copyShard(client, sourceNodeID, destinationNodeID, shardID, true)
		case "mirror-all-shards":
			if len(token) < 3 {
				return ErrLessArguments
			}
			sourceNodeID, _ := strconv.ParseUint(token[1], 10, 64)
			destinationNodeID, _ := strconv.ParseUint(token[2], 10, 64)

			return MirrorShardsFromTo(client, sourceNodeID, destinationNodeID)
		case "copy-all-cold-shards-to":
			if len(token) < 3 {
				return ErrLessArguments
			}
			sourceNodeID, _ := strconv.ParseUint(token[1], 10, 64)
			destinationNodeID, _ := strconv.ParseUint(token[2], 10, 64)
			return copyAllColdShards(client, sourceNodeID, destinationNodeID, false)
		case "reclaim-shards":
			if len(token) < 2 {
				return ErrLessArguments
			}
			nodeID, _ := strconv.ParseUint(token[1], 10, 64)
			return pullShards(client, nodeID)
		case "add-shard-owner":
			if len(token) < 3 {
				return ErrLessArguments
			}
			shardID, _ := strconv.ParseUint(token[1], 10, 64)
			nodeID, _ := strconv.ParseUint(token[2], 10, 64)
			err := client.AddShardOwner(shardID, nodeID)
			if err != nil {
				fmt.Printf("Failed: %s\n", err.Error())
			} else {
				fmt.Println("Success.")
			}
			return nil
		case "remove-shard-owner":
			if len(token) < 3 {
				return ErrLessArguments
			}
			shardID, _ := strconv.ParseUint(token[1], 10, 64)
			nodeID, _ := strconv.ParseUint(token[2], 10, 64)
			err := client.DelShardOwner(shardID, nodeID)
			if err != nil {
				fmt.Printf("Failed: %s.\n", err.Error())
			} else {
				fmt.Printf("Success.\n")
			}
			return nil
		case "drop-shard-on":
			if len(token) < 3 {
				return ErrLessArguments
			}
			shardID, _ := strconv.ParseUint(token[1], 10, 64)
			nodeID, _ := strconv.ParseUint(token[2], 10, 64)
			node, _ := client.DataNode(nodeID)
			if node == nil {
				fmt.Printf("cant not find Node %d in cluster\n", nodeID)
				return nil
				//return errors.New("node cant find")
			}
			rebCli := rebalance.NewClient(node.TCPHost)
			rep, err := rebCli.SendDropShardRequest(shardID)
			if err != nil {
				fmt.Printf("%s\n", err.Error())
			} else {
				fmt.Printf("%s\n", rep.Message)
			}
			return nil
		case "exit", "quit", "q":
			return exit()
		case "show-command":
			command()
		case "":
			return ErrBlankCommand
		default:
			command()
		}
	} else {
		command()
	}
	return nil
}

func main() {
	username := flag.String("meta-user", "", "")
	password := flag.String("meta-password", "", "")
	metaServer := flag.String("meta-server", "", "")
	help := flag.Bool("help", false, "")
	flag.Parse()

	if *help || "" == *metaServer {
		usage()
		return
	}

	authEnabled := false
	if *username != "" || *password != "" {
		authEnabled = true
	}

	client := meta.NewClient(nil, authEnabled, *username, *password)
	client.SetMetaServers(strings.Split(*metaServer, ","))
	if err := client.OpenForMetaAdmin(); err != nil {
		fmt.Printf("Client Open Failed: %s\n", err.Error())
		return
	}
	defer client.Close()

	osSignals := make(chan os.Signal, 1)
	signal.Notify(osSignals, os.Kill, os.Interrupt, syscall.SIGTERM, syscall.SIGQUIT, syscall.SIGHUP)

	line_in := liner.NewLiner()
	defer line_in.Close()

	closing := make(chan struct{})
	for {
		select {
		case <-osSignals:
			close(closing)
		case <-closing:
			client.Close()
			line_in.Close()
			return
		default:
			line, e := line_in.Prompt("> ")
			if e == io.EOF {
				line = "exit"
			} else if e != nil {
				break
			}

			err := parseCommand(line, client, *username, *password)

			if err == QuitCommand {
				close(closing)
			} else if err != nil && err != ErrBlankCommand {
				line_in.AppendHistory(line)
				fmt.Println(err)
			} else if err == nil {
				line_in.AppendHistory(line)
			}
		}
	}
	return
}
