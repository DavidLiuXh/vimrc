#include "http_server.h"

#include <thread>

#include <glog/logging.h>

#include <pistache/net.h>
#include <pistache/tcp.h>
#include <pistache/router.h>

#include "config_storage.h"

namespace qcm {
namespace http {

const unsigned int WORK_THREAD_SIZE_ADJUST_DEFAULD = 2;
const std::string CONFIG_URI_QUERY_KEY = "key";

HttpServer::HttpServer(const std::shared_ptr<store::ConfigStorage>& config_storage)
:config_storage_(config_storage) {
}

HttpServer::~HttpServer() {
}

bool HttpServer::Start(const Config& config, bool run_in_thread) {
  bool rt = false;

  try {
    if (!config.ip.empty() &&
        config.port > 0 &&
        !server_) {
      Pistache::Address addr(config.ip, config.port);
      server_.reset(new Pistache::Http::Endpoint(addr));
      if (server_) {
        unsigned int work_thread_size = config.work_thread_size;
        if (0 == work_thread_size) {
          work_thread_size = std::thread::hardware_concurrency();
          if (work_thread_size > WORK_THREAD_SIZE_ADJUST_DEFAULD) {
            work_thread_size -= WORK_THREAD_SIZE_ADJUST_DEFAULD;
          }
        }

        auto opts = Pistache::Http::Endpoint::options()
          .threads(work_thread_size)
          .flags(Pistache::Tcp::Options::ReuseAddr);

        server_->init(opts);

        if (BuildRouter()) {
          server_->setHandler(router_->handler());
        }

        if (run_in_thread) {
          server_->serveThreaded();
        } else {
          server_->serve();
        }

        rt = true;

        LOG(INFO) << "Successful start Http Server | ip: " << config.ip
          << " | port: " << config.port
          << " | work_thread_size: " << config.work_thread_size;
      }
    } else {
      LOG(ERROR) << "Failed to Start HttpServer | ip: " << config.ip
        << " | port: " << config.port
        << " | work_thread_size: " << config.work_thread_size
        << " | already start: " << !server_;
    }
  } catch (std::runtime_error& e) {
    rt = false;
    LOG(ERROR) << "HttpServer Start throw runtime_error exception: " << e.what();
  } catch (std::exception& e) {
    LOG(ERROR) << "HttpServer Start throw std::exception: " << e.what();
  } catch (...) {
    LOG(ERROR) << "HttpServer Start throw exception";
  }

  return rt;
}

void HttpServer::Stop() {
  LOG(INFO) << "Starting stop Http Server ...";

  if (server_) {
    try {
      server_->shutdown();
      router_.reset();
      server_.reset();
    } catch (std::runtime_error& e) {
      LOG(ERROR) << "HttpServer stop throw runtime_error exception: " << e.what();
    } catch (std::exception& e) {
      LOG(ERROR) << "HttpServer stop throw std::exception: " << e.what();
    } catch (...) {
      LOG(ERROR) << "HttpServer stop throw exception";
    }

    LOG(INFO) << "Finished stop Http Server";
  }
}

bool HttpServer::BuildRouter() {
  bool rt = false;

  router_.reset(new Pistache::Rest::Router());
  if (router_) {
    Pistache::Rest::Routes::Get(*router_,
        "/status",
        Pistache::Rest::Routes::bind(&HttpServer::Ping, this));

    Pistache::Rest::Routes::Get(*router_,
        "/config",
        Pistache::Rest::Routes::bind(&HttpServer::GetConfig, this));

    Pistache::Rest::Routes::Get(*router_,
        "/configversion",
        Pistache::Rest::Routes::bind(&HttpServer::GetConfigVersion, this));

    rt = true;
  }

  return rt;
}

void HttpServer::Ping(const Pistache::Rest::Request&, Pistache::Http::ResponseWriter response) {
  response.send(Pistache::Http::Code::Ok, "ok\n");
}

void HttpServer::GetConfig(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
  const Pistache::Http::Uri::Query& query = request.query();
  std::string key = query.get(CONFIG_URI_QUERY_KEY).getOrElse("");
  LOG(INFO) << "HttServer | GetConfig | key: " << key;

  if (!key.empty()) {
    std::string value("");
    int64_t revision = -1;
    if (config_storage_ &&
        config_storage_->Get(key, &value, &revision)) {
      response.send(Pistache::Http::Code::Ok, value);
    } else {
      response.send(Pistache::Http::Code::No_Content);
    }
  } else {
      response.send(Pistache::Http::Code::Bad_Request,
          "key is null");
  }
}

void HttpServer::GetConfigVersion(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
  const Pistache::Http::Uri::Query& query = request.query();
  std::string key = query.get(CONFIG_URI_QUERY_KEY).getOrElse("");
  LOG(INFO) << "HttServer | GetConfig | key: " << key;

  if (!key.empty()) {
    std::string value("");
    int64_t revision = -1;
    if (config_storage_ &&
        config_storage_->Get(key, &value, &revision)) {
      std::string version("");
      try {
        version = std::to_string(revision)
      } catch (...) {
        LOG(ERROR) << "HttpServer | Failed to std::to_string | key: " << key;
      }

      response.send(Pistache::Http::Code::Ok, version);
    } else {
      response.send(Pistache::Http::Code::No_Content);
    }
  } else {
      response.send(Pistache::Http::Code::Bad_Request,
          "key is null");
  }
}
}//namespace http
}//namespace qcm
