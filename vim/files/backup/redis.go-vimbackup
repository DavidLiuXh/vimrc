package models

import (
	"github.com/astaxie/beego"
	"github.com/go-redis/redis"
	"strconv"
	"strings"
)

var (
	RedisObj RedisObject
)

const (
	RETRY_TIME = 3
)

type RedisObject struct {
	client  *redis.Client
	uri     string
	pass    string
	db      int
	timeout int64
}

func InitRedis() (rt bool) {
	rt = false

	RedisObj.uri = beego.AppConfig.DefaultString("redis_uri", "")
	RedisObj.pass = beego.AppConfig.DefaultString("redis_pass", "")
	RedisObj.db = beego.AppConfig.DefaultInt("redis_db", 0)

	beego.Info("InitRedis | uri: ", RedisObj.uri)

	rt = CreateRedisClient()

	return rt
}

func CreateRedisClient() (rt bool) {
	rt = false

	if RedisObj.uri != "" &&
		RedisObj.pass != "" {
		client := redis.NewClient(&redis.Options{
			Addr:     RedisObj.uri,
			Password: RedisObj.pass,
			DB:       RedisObj.db,
		})

		if nil != client {
			_, err := client.Ping().Result()
			if err != nil {
				beego.Error("InitRedis | failed to ping | error msg: ", err)
			} else {
				RedisObj.client = client
				rt = true
			}
		}
	} else {
		beego.Error("Failed to InitRedis | uri: ", RedisObj.uri,
			" | pass: ", RedisObj.pass,
			" | db: ", RedisObj.db)
	}

	return rt
}

func GetSyncStatus(requesti interface{}, responsei interface{}) {
	var request = requesti.(*GetSyncStatusRequest)
	var response = responsei.(*GetSyncStatusResponse)

	response.ConfigKey = request.ConfigKey

	errCode := OK
	errMsg := ""

	if request.ConfigKey == "" {
		beego.Error("GetSyncStatus | failed | key: ", request.ConfigKey,
			" | reversion: ", request.ConfigReversion)
		errCode = KEY_OR_VALUE_IS_NULL
	} else if nil != RedisObj.client {
		retryTime := 0
	RETRY:
		strStrMapCmd := RedisObj.client.HGetAll(request.ConfigKey)
		if nil != strStrMapCmd {
			if stringSlice, err := strStrMapCmd.Result(); nil != err {
				errCode = INTERNAL_ERROR_REDIS
				errMsg = err.Error()

				if errMsg == "EOF" &&
					retryTime <= RETRY_TIME {
					errMsg = ""
					errCode = OK
					retryTime += 1

					RedisObj.client.Close()
					CreateRedisClient()

					goto RETRY
				}
			} else {
				for key, value := range stringSlice {
					syncDataList := strings.Split(value, "_")
					var reversion int64 = -1
					var timestamp int64 = -1
					if r, _ := strconv.ParseInt(syncDataList[0], 10, 64); nil == err {
						reversion = r
					}

					if r, _ := strconv.ParseInt(syncDataList[1], 10, 64); nil == err {
						timestamp = r
					}
					response.SyncList = append(response.SyncList, SyncData{
						IpPort:    key,
						Reversion: reversion,
						Timestamp: timestamp,
					})
				}
			}
		} else {
			errCode = INTERNAL_ERROR_REDIS
		}
	} else {
		errCode = INTERNAL_ERROR_REDIS
	}

	response.ErrorCode = errCode
	if errMsg != "" {
		response.ErrorMsg = ERROR_MSG[errCode] + " : " + errMsg
	} else {
		response.ErrorMsg = ERROR_MSG[errCode]
	}
}
