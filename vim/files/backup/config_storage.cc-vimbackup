#include "config_storage.h"

#include <thread>

#include <glog/logging.h>
#include <json/json.h>

#include "file_operation.h"
#include "updater.h"

namespace store {

const std::string ConfigStorage::kValueFieldName = "config_value";

ConfigStorage::ConfigStorage(size_t bucket_num, size_t init_size,
                             const std::shared_ptr<peanuts::Updater>& updater)
    : config_revision_(new ConfigRevision(bucket_num, init_size)),
      updater_(updater) {}

ConfigStorage::ConfigStorage(ConfigStorage&& other) noexcept
    : config_revision_(std::move(other.config_revision_)),
      storage_(std::move(other.storage_)),
      updater_(std::move(other.updater_)) {}

ConfigStorage& ConfigStorage::operator=(ConfigStorage&& other) noexcept {
  if (this != &other) {
    config_revision_ = std::move(other.config_revision_);
    storage_ = std::move(other.storage_);
    updater_ = std::move(other.updater_);
  }

  return *this;
}

int64_t ConfigStorage::Init(const std::string& prefix,
                            const std::string& dbname,
                            bool serve_without_etcd,
                            const std::unique_ptr<EtcdClient>& etcd_client) {
  LOG(INFO) << "ConfigStorage::Init.";
  using etcdserverpb::RangeResponse;
  RangeResponse response;
  if (etcd_client->GetPrefixedWith(prefix, &response)) {
    return FullSync(dbname, response);
  }

  LOG(ERROR) << "ConfigStorage::Init--GetPrefixedWith(" << prefix << ") Failed.";

  if (serve_without_etcd) {
    return Recover(dbname);
  }

  LOG(ERROR) << "ConfigStorage::Init--No Serve Without Etcd.";
  LOG(ERROR) << "ConfigStorage::Init--Failed.";
  return -1;
}

int64_t ConfigStorage::FullSync(const std::string& dbname,
                                const etcdserverpb::RangeResponse& response) {
  LOG(INFO) << "ConfigStorage::FullSync.";
  if (!RemoveDir(dbname)) {
    LOG(ERROR) << "ConfigStorage::FullSync--RemoveDir(" << dbname << ") Failed.";
    LOG(ERROR) << "ConfigStorage::FullSync--Failed.";
    return -1;
  }

  storage_.reset(NewStorage(dbname));
  if (nullptr == storage_) {
    LOG(ERROR) << "ConfigStorage::FullSync--NewStorage(" << dbname << ") Failed.";
    LOG(ERROR) << "ConfigStorage::FullSync--Failed.";
    return -1;
  }

  if (!storage_->SetValid(false)) {
    LOG(ERROR) << "ConfigStorage::FullSync--SetValid(false) Failed.";
    LOG(ERROR) << "ConfigStorage::FullSync--Failed.";
    return -1;
  }

  for (int i = 0; i < response.kvs_size(); i++) {
    using mvccpb::KeyValue;
    const KeyValue& kv = response.kvs(i);
    LOG(INFO) << "ConfigStorage::FullSync--Put("
              << kv.key() << ", " << kv.value() << ", "
              << kv.mod_revision() << ").";
    if (!Put(kv.key(), kv.value(), kv.mod_revision(), false)) {
      LOG(ERROR) << "ConfigStorage::FullSync--Put("
                 << kv.key() << ", " << kv.value() << ", "
                 << kv.mod_revision() << ") Failed.";
    LOG(ERROR) << "ConfigStorage::FullSync--Failed.";
      return -1;
    }
  }

  if (!storage_->SetValid(true)) {
    LOG(ERROR) << "ConfigStorage::FullSync--SetValid(true) Failed.";
    LOG(ERROR) << "ConfigStorage::FullSync--Failed.";
    return -1;
  }

  LOG(INFO) << "ConfigStorage::FullSync--Success.";
  return 0 == response.kvs_size() ?
         0 : response.kvs(response.kvs_size() - 1).mod_revision();
}

int64_t ConfigStorage::Recover(const std::string& dbname) {
  LOG(INFO) << "ConfigStorage::Recover.";
  storage_.reset(NewStorage(dbname));
  if (nullptr == storage_) {
    LOG(ERROR) << "ConfigStorage::Recover--NewStorage(" << dbname << ") Failed.";
    LOG(ERROR) << "ConfigStorage::Revover--Failed.";
    return -1;
  }

  if (!storage_->IsValid()) {
    LOG(ERROR) << "ConfigStorage::Recover--Storage Is Not Valid.";
    LOG(ERROR) << "ConfigStorage::Revover--Failed.";
    return -1;
  }

  int64_t current_revision = 0;
  std::unique_ptr<Storage::Iterator> iter = storage_->NewIterator();
  for (iter->First(); iter->Valid(); iter->Next()) {
    int64_t revision = iter->Revision();
    config_revision_->Put(iter->Key(), revision);

    if (revision > current_revision) { current_revision = revision; }
  }
  if (!iter->Status()) {
    LOG(ERROR) << "ConfigStorage::Recover--Traverse Storage Failed.";
    LOG(ERROR) << "ConfigStorage::Revover--Failed.";
    return -1;
  }

  LOG(INFO) << "ConfigStorage::Recover--Success.";
  return current_revision;
}

bool ConfigStorage::Put(const std::string& key, const std::string& value,
                        int64_t revision, bool notify) {
  LOG(INFO) << "ConfigStorage::Put.";
  std::string real_value;
  if (!Decode(value, &real_value)) {
    LOG(ERROR) << "ConfigStorage::Put--Decode(" << value << ") Failed.";
    LOG(ERROR) << "ConfigStorage::Put--Ignore.";
    return true;
  }

  if (!storage_->Put(key, real_value, revision)) {
    LOG(ERROR) << "ConfigStorage::Put--Storage::Put("
               << key << ", " << value << ", " << revision << ") Falied.";
    LOG(ERROR) << "ConfigStorage::Put--Failed.";
    return false;
  }
  config_revision_->Put(key, revision);

  if (notify &&
      updater_) {
    LOG(INFO) << "ConfigStorage::Put--Notify.";
    updater_->PushNew({key, revision, real_value});
  }

  LOG(INFO) << "ConfigStorage::Put--Success.";
  return true;
}

bool ConfigStorage::Get(const std::string& key, std::string* value, int64_t* revision) {
  LOG(INFO) << "ConfigStorage::Get.";
  return storage_->Get(key, value, revision);
}

bool ConfigStorage::Del(const std::string& key) {
  LOG(INFO) << "ConfigStorage::Del.";
  if (!storage_->Del(key)) {
    LOG(ERROR) << "ConfigStorage::Del--Storage::Del(" << key << ") Failed.";
    LOG(ERROR) << "ConfigStorage::Del--Failed.";
    return false;
  }
  config_revision_->Del(key);

  LOG(INFO) << "ConfigStorage::Del--Success.";
  return true;
}

bool ConfigStorage::GetNewerVersion(const std::string& key, int64_t revision,
                                    std::string* value, int64_t* new_revision) {
  LOG(INFO) << "ConfigStorage::GetNewerVersion.";
  *new_revision = config_revision_->Get(key);
  if (-1 != *new_revision && *new_revision <= revision) {
    LOG(INFO) << "ConfigStorage::GetNewerVersion--There Is No Newer Version.";
    return false;
  }

  if (!storage_->Get(key, value, new_revision)) {
    LOG(ERROR) << "ConfigStorage::GetNewerVersion--Storage::Get(" << key << ") Failed.";
    LOG(ERROR) << "ConfigStorage::GetNewerVersion--Failed.";
    return false;
  }

  if (*new_revision <= revision) {
    LOG(INFO) << "ConfigStorage::GetNewerVersion--There Is No Newer Version.";
    return false;
  }

  LOG(INFO) << "ConfigStorage::GetNewerVersion--Success.";
  return true;
}

bool ConfigStorage::Decode(const std::string& src, std::string* dst) {
  LOG(INFO) << "ConfigStorage::Deocde.";
  Json::CharReaderBuilder builder;
  std::unique_ptr<Json::CharReader> reader(builder.newCharReader());
  Json::Value root;
  JSONCPP_STRING errs;
  if (!reader->parse(src.data(), src.data() + src.length(), &root, &errs)) {
    LOG(ERROR) << "ConfigStorage::Decode--Parse Failed.";
    LOG(ERROR) << "ConfigStorage::Decode--Failed.";
    return false;
  }

  if (!root.isObject() || !root.isMember(kValueFieldName)) {
    LOG(ERROR) << "ConfigStorage::Deocde--Not A Object or No [" << kValueFieldName << "] Member.";
    LOG(ERROR) << "ConfigStorage::Deocde--Failed.";
    return false;
  }

  if (!root[kValueFieldName].isString()) {
    LOG(ERROR) << "ConfigStorage::Decode--[" << kValueFieldName << "] Is Not A String.";
    LOG(ERROR) << "ConfigStorage::Deocde--Failed.";
    return false;
  }

  *dst = URLDecode(root[kValueFieldName].asString());

  LOG(INFO) << "ConfigStorage::Deocde--Success.";
  return true;
}

std::string ConfigStorage::URLDecode(const std::string& src) {
  LOG(INFO) << "ConfigStorage::URLDeocde.";
  std::string dst;
  for (size_t i = 0; i < src.length(); i++) {
    int n;
    char c;
    if ('%' == src[i]) {
      sscanf(src.substr(i + 1, 2).c_str(), "%x", &n);
      c = static_cast<char>(n);
      dst.push_back(c);
      i += 2;
    } else {
      dst.push_back(src[i]);
    }
  }

  LOG(INFO) << "ConfigStorage::URLDecode--Success.";
  return dst;
}

} // namespace store
