#include <iostream>
#include <vector>
#include <queue>
#include <set>
#include <map>
#include <limits>
#include <algorithm>

//------------------------ Binary Search
int BinarySearch(int a[], int leng, int search_int) {
  int search_result = -1;

  if (leng > 0 &&
      nullptr != a) {
    int low = 0;
    int hig = leng - 1;
    int midle = -1;

    while (hig >= low) {
      midle = (hig + low) / 2;

      if (search_int == a[midle]) {
        search_result = midle;
        break;
      } else if (search_int > a[midle]) {
        low = midle + 1;
      } else {
        hig = midle - 1;
      }
    }
  }

  return search_result;
}

void TestBinarySearch(char *argv[]) {
  std::cout << "Start Binary Search" << std::endl;
  int a[] {1, 3, 5, 7, 9};
  int found = BinarySearch(a, sizeof(a) / sizeof(a[0]), atoi(argv[1]));
  std::cout << "found: " << found << std::endl;
}

//------------------------ Selection Sort
void SelectionSort(int a[], int leng) {
  for (int i = leng - 1; i > 0; --i) {
    for (int j = 0; j < leng - 2; ++j) {
      if (a[i] > a[j]) {
        std::swap(a[i], a[j]);
      }
    }
  }
}

void TestSelectionSort() {
  std::cout << "Start Selection sort" << std::endl;
  int a[] {1, 3, 5, 7, 9};
  SelectionSort(a, sizeof(a) / sizeof(a[0]));
  for (auto& i : a) {
    std::cout << i << ",";
  }
  std::cout << std::endl;
}

//------------------------ Bubble Sort
void BubbleSort(int a[], int leng) {
  bool is_continue = true;
  while (is_continue) {
    is_continue = false;

    for (int i = 0; i < leng - 1; ++i) {
      if (a[i] < a[i + 1]) {
        std::swap(a[i], a[i + 1]);
        is_continue = true;
      }
    }
  }
}

void TestBubbleSort() {
  std::cout << "Start Bubble sort" << std::endl;
  int a[] {1, 3, 5, 0, -1, 9};
  BubbleSort(a, sizeof(a) / sizeof(a[0]));
  for (auto& i : a) {
    std::cout << i << ",";
  }
  std::cout << std::endl;
}
//------------------------ Recursive test
void TestRecursive() {
  //int m = 1680;
  //int n = 640;
  int m = 16;
  int n = 6;
  while(n != 0){
    long rem = m % n;
    m = n;
    n = rem;
  }

  std::cout << m << std::endl; 
}

int sum(int a[], int leng) {
  if (0 == leng) {
    return 0;
  } else {
    return a[0] + sum(a + 1, leng -1);
  }
}
void TestRecursiveSum() {
  int a[] {1, 3, 5, 7, 9};
  std::cout << sum(a, sizeof(a) / sizeof(a[0])) << std::endl;
}
//------------------------ Quick sort 
int* QuickSort(int a[], int start,  int end) {
  std::cout << "start : " << start << " | end : " << end << std::endl; 
  if (end - start  < 1) {
    return a;
  } else if (end - start == 1) {
    if (a[start] < a[end]) {
      std::swap(a[start], a[end]);
    }
    return a;
  }

  int midle = (start + end) / 2;
  int midle_value = a[midle];

  int i = start;
  int j = end;
  while (i < midle && j > midle) {
    while (i < midle && a[i] > midle_value) {
      ++i;
    }

    while (j > midle && a[j] < midle_value) {
      --j;
    }

    if (j > i &&
        i < midle &&
        j > midle) {
      std::swap(a[i++], a[j--]);
    }
  }

  if (j > midle) {
    std::swap(a[midle], a[j]);
    //midle = i;
  } else if (i < midle) {
    std::swap(a[midle], a[i]);
    //midle = j;
  }

  for (int i = 0; i < 6;++i) {
    std::cout << a[i] << ",";
  }

  std::cout << "xxxx | " << midle << std::endl;

  QuickSort(a, start, midle - 1);
  QuickSort(a, midle + 1, end);

  return a;
}

void TestQuickSort() {
  std::cout << "Start Quick sort" << std::endl;
  int a[] {1, 3,2, 5, 0, -1, 9};
  //int a[] {9, 5, 3, 0, 1, -1};

  QuickSort(a, 0, sizeof(a) / sizeof(a[0]) - 1);

  for (auto& i : a) {
    std::cout << i << ",";
  }
  std::cout << std::endl;
}
//------------------------ Breadth-first Search
struct Person {
  char name;
  std::vector<Person*> friends;
  Person* parent;
  bool search;
};

void PushPerson(std::queue<Person*>& queue, Person* person) {
  for (auto p : person->friends) {
    if (!p->search) {
      if (nullptr == p->parent) {
        p->parent = person;
      }
      queue.push(p);
    }
  }
}

void BreadthFirstSearch() {
  Person d { 'd' };
  Person f { 'f' };
  Person g { 'g' };
  Person e {
    'e',
      {&f}
  };
  Person c {
    'c',
      {&g}
  };
  Person b {
    'b',
      {&e}
  };

  Person a {
    'a',
      {&d, &e}
  };
  Person o {
    'o',
      {&a, &b, &c}
  };

  std::queue<Person*> search_queue;

  char found_name = f.name;
  Person *found = nullptr;

  PushPerson(search_queue, &o);
  while (!search_queue.empty()) {
    Person *current = search_queue.front();
    search_queue.pop();
    if (current->name == found_name) {
      found = current;
      break;
    } else {
      current->search = true;
      PushPerson(search_queue, current);
    }
  }

  if (nullptr != found) {
    std::cout << "Found: " << found->name << std::endl;
    Person * tmp = found->parent;
    while (nullptr != tmp) {
      std::cout << " " << tmp->name;
      tmp = tmp->parent;
    }
    std::cout << std::endl;
  }
}
//------------------------ 最大公约数
int Gcd(int a, int b) {
  if (a == b) {
    return a;
  } else if (a > b) {
    Gcd(a-b, b);
  } else {
    Gcd(a, b - a);
  }
}

void TestGcd(int a, int b) {
  int gcd = Gcd(a, b);
  std::cout << a << " : " << b << " => " << Gcd(a, b) << std::endl;
}
//------------------------ Dijkstra
struct Place;
struct Neighbor {
  Place* neighbor;
  int weight;
};

struct Place {
  std::string name;
  std::vector<Neighbor> neighbors;
  bool first;
  Place* parent;
};

struct Cost {
  Place* place;
  int value;

  Cost()
    :place(nullptr)
     ,value(-1) {
     }
};

//typedef std::map<Place*, Cost> PlaceMap;
typedef std::map<Place*, int> PlaceMap;

Place* FindPlace(PlaceMap& place_map) {
  int base_weight = std::numeric_limits<int>::max();
  Place* found = nullptr;
  for (auto i = place_map.begin(), e = place_map.end();
      i != e;
      ++i) {
    if  (!i->first->first && i->second < base_weight) {
      found = i->first;
      base_weight = i->second;
    }
  }

  if (nullptr != found) {
    found->first = true;
  }

  return found;
}

void TestDijkstra() {
  //build DAG
  Place G {
    "G",
      {},
      false,
      nullptr
  };

  Place D {
    "D",
      {{
         &G,
         5
       }},
      false,
      nullptr
  };

  Place F {
    "F",
      {{
         &G,
        4 
       }},
      false,
      nullptr
  };

  Place B {
    "B",
      {{
         &D,
        9 
       }},
      false,
      nullptr
  };

  Place C {
    "C",
      {{
         &F,
        6 
       },
      {
        &B,
        1
      }},
      false,
      nullptr
  };
  Place A {
    "A",
      {
        {
          &B,
          2
        },
        {
          &C,
          3
        }
      },
      false,
      nullptr
  };

  //search A => G
  PlaceMap costs;

  //startup
  for (Neighbor& n : A.neighbors) {
    costs[n.neighbor] += n.weight;
    n.neighbor->parent = &A;
  }
  A.first = true;
  costs[&G] = std::numeric_limits<int>::max();

  // found next node
  Place* current = FindPlace(costs);

  while (nullptr != current) {
    for (Neighbor& n : current->neighbors) {
      int current_value = costs[n.neighbor];
      if (0 == current_value) {
        costs[n.neighbor] = n.weight + costs[current];
        n.neighbor->parent = current;
      } else if (n.weight + costs[current] < costs[n.neighbor]) {
        costs[n.neighbor] = n.weight + costs[current];
        n.neighbor->parent = current;
      }
    }
    current->first = true;

    current = FindPlace(costs);
  }

  //print found path
  Place* tmp = &G;
  while(nullptr != tmp) {
    std::cout << tmp->name << std::endl;
    tmp = tmp->parent;
  }
}
//------------------------ BST 二叉搜索树
struct Node {
  int value;
  Node* left;
  Node* right;
  Node* parent;

  Node(int v)
    :value(v)
     ,left(nullptr)
     ,right(nullptr)
     ,parent(nullptr) {
     }
};

void InsertBST(Node** rootnode, Node* insert_node) {
  if (nullptr == *rootnode) {
    *rootnode = insert_node;
    insert_node->parent = *rootnode;
  } else {
    if ((*rootnode)->value > insert_node->value) {
      InsertBST(&((*rootnode)->left), insert_node);
    } else {
      InsertBST(&((*rootnode)->right), insert_node);
    }
  }
}

void InOrderBST(Node* root) {
  if (nullptr != root) {
    InOrderBST(root->left);
    std::cout << root->value << std::endl;
    InOrderBST(root->right);
  }
}

void TestBST() {
  int a[] = {
    9, 8, 1, 10, 2, 4
  };

  Node* root = nullptr;
  for (auto i : a) {
    Node* node = new Node(i);
    if (nullptr != node) {
      InsertBST(&root, node);
    }
  }


  InOrderBST(root);
}
//------------------------ build BST by Inorder and Preorder
Node* BuildByPreAndIn(Node** preorder, int preorde_size,
    Node** inorder, int inorder_size,
    Node** parent) {
    std::cout << preorde_size << " | " << inorder_size << std::endl;
  if (nullptr != preorder &&
      preorde_size > 0) {
    if (nullptr == *parent) {
      *parent = preorder[0];
    }

    preorder[0]->parent = *parent;

    std::vector<Node*> inorder_left;
    std::vector<Node*> inorder_right;
    bool flag = false;
    for (int i = 0; i< inorder_size; ++i) {
      Node* node = inorder[i];
      if (node == preorder[0]) {
        flag = true;
        continue;
      }

      if (!flag) {
        inorder_left.push_back(node);
      } else {
        inorder_right.push_back(node);
      }
    }

    std::vector<Node*> preorder_left;
    std::vector<Node*> preorder_right;
    for (int i = 1; i < preorde_size; ++i) {
      Node* node = preorder[i];
      std::vector<Node*>::iterator found = std::find(inorder_left.begin(),
          inorder_left.end(),
          node);
      if (found != inorder_left.end()) {
        preorder_left.push_back(node);
      } else {
        preorder_right.push_back(node);
      }
    }

    if (preorde_size <= 3) {
      if (!inorder_left.empty()) {
        preorder[0]->left = inorder_left[0];
      }

      if (!inorder_right.empty()) {
        preorder[0]->right = inorder_right[0];
      }

      return preorder[0];
    }

    if (!preorder_left.empty()) {
      Node* left_root = BuildByPreAndIn(&preorder_left[0], preorder_left.size(),
          &inorder_left[0], inorder_left.size(),
          &preorder[0]);

      (*parent)->left = left_root;
    }

    if (!preorder_right.empty()) {
      Node* righ_root = BuildByPreAndIn(&preorder_right[0], preorder_right.size(),
          &inorder_right[0], inorder_right.size(),
          &preorder[0]);
      (*parent)->right = righ_root;
    }
  }

  return *parent;
}

void TestBuild() {
  Node a1(1);
  Node a2(2);
  Node a3(3);
  Node a4(4);
  Node a5(5);
  Node a6(6);

  Node* preorde[] {
    &a1, &a2, &a4, &a3, &a5, &a6
  };
  Node* inorde[] {
    &a4, &a2, &a1, &a5, &a3, &a6
  };

  Node* root = nullptr;
  BuildByPreAndIn(preorde, 6, inorde, 6, &root);

  InOrderBST(root);
}
//------------------------ InsertSort
// 时间复杂度 O(n的3次方)
void TestInsertSort() {
  int a[] = {
    3, 1, 4, 2, 5
  };

  for (int i = 1; i < sizeof(a)/sizeof(a[0]); ++i) {
    for (int j = 0; j < i; ++j) {
      if (a[j] > a[i]) {
        int tmp = a[i];
        for (int k = i - 1; k >= j; --k) {
          a[k + 1] = a[k];
        }

        a[j] = tmp;
      }
    }
  }

  for (auto i : a) {
    std::cout << i << std::endl;
  }
}

void TestInsertSort2() {
  int a[] = {
    3, 1, 4, 2, 5
  };

  for (int i = 1; i < sizeof(a)/sizeof(a[0]); ++i) {
    for (int j = i; j >= 0 ; --j) {
      if (a[j - 1] > a[j]) {
        std::swap(a[j - 1], a[j]);
      }
    }
  }

  for (auto i : a) {
    std::cout << i << std::endl;
  }
}
//------------------------ main
int main(int argc, char *argv[]) {
  //TestBinarySearch(argv);
  //TestSelectionSort();
  //TestBubbleSort();
  //TestRecursive();
  //TestRecursiveSum();
  //TestQuickSort();
  //BreadthFirstSearch();
  //TestGcd(13, 8); 
  //TestDijkstra();
  //TestBST();
  //TestBuild();
  TestInsertSort2();
  
  return 0;
}
