package run

import (
	"log"
	"os"
	"os/exec"
	"syscall"
	"time"
)

func Daemon() {

	// short delay to avoid race condition between
	// os.StartProcess and os.Exit
	// can be omitted if the work done above
	// amounts to a sufficient delay
	time.Sleep(1 * time.Second)

	if os.Getppid() != 1 {
		// I am the parent, spawn
		// child to run as daemon
		binary, err := exec.LookPath(os.Args[0])
		if err != nil {
			log.Fatalln("Failed to lookup binary:", err)
		}
		_, err = os.StartProcess(binary, os.Args, &os.ProcAttr{Dir: "", Env: nil,
			Files: []*os.File{os.Stdin, os.Stdout, os.Stderr}, Sys: nil})
		if err != nil {
			log.Fatalln("Failed to start process:", err)
		}
		os.Exit(0)
	} else {
		_, err := syscall.Setsid()
		if err != nil {
			log.Fatalln("Failed to create new session:", err)
		}
		file, err := os.OpenFile("/dev/null", os.O_RDWR, 0)
		if err != nil {
			log.Fatalln("Failed to open /dev/null:", err)
		}
		// !lw! redirect os.Stderr to panic log file to log panic
		syscall.Dup2(int(file.Fd()), int(os.Stdin.Fd()))
		syscall.Dup2(int(file.Fd()), int(os.Stdout.Fd()))
		file.Close()
	}

}
