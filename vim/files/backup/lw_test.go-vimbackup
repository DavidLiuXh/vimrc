package tsm1_test

import (
	"context"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"testing"

	"github.com/influxdata/influxdb/tsdb/engine/tsm1"
)

func newFiles(dir string, values ...[]keyValues) ([]string, error) {
	var files []string

	id := 1
	for _, v := range values {
		f := MustTempFile(dir)
		w, err := tsm1.NewTSMWriter(f)
		if err != nil {
			return nil, err
		}

		for _, subkv := range v {
			if err := w.Write([]byte(subkv.key), subkv.values); err != nil {
				return nil, err
			}
		}
		if err := w.WriteIndex(); err != nil {
			return nil, err
		}

		if err := w.Close(); err != nil {
			return nil, err
		}

		newName := filepath.Join(filepath.Dir(f.Name()), tsm1.DefaultFormatFileName(id, 1)+".tsm")
		if err := os.Rename(f.Name(), newName); err != nil {
			return nil, err
		}
		id++

		files = append(files, newName)
	}
	return files, nil
}

type keyValues struct {
	key    string
	values []tsm1.Value
}

func MustTempDir() string {
	dir, err := ioutil.TempDir("", "tsm1-test")
	if err != nil {
		panic(fmt.Sprintf("failed to create temp dir: %v", err))
	}
	return dir
}

func MustTempFile(dir string) *os.File {
	f, err := ioutil.TempFile(dir, "tsm1test")
	if err != nil {
		panic(fmt.Sprintf("failed to create temp file: %v", err))
	}
	return f
}

func fatal(t *testing.T, msg string, err error) {
	t.Fatalf("unexpected error %v: %v", msg, err)
}

func TestFileStore_SeekToAsc_FromStart_lw(t *testing.T) {
	dir := MustTempDir()
	defer os.RemoveAll(dir)
	fs := tsm1.NewFileStore(dir)

	// Setup 3 files
	data := [][]keyValues{
		[]keyValues{
			keyValues{"a", []tsm1.Value{tsm1.NewValue(1, 2.0)}},
			keyValues{"b", []tsm1.Value{tsm1.NewValue(1, 2.0)}},
			keyValues{"c", []tsm1.Value{tsm1.NewValue(1, 2.0)}},
			keyValues{"d", []tsm1.Value{tsm1.NewValue(1, 2.0)}},
		},
		[]keyValues{
			keyValues{"d", []tsm1.Value{tsm1.NewValue(1, 2.0)}},
			keyValues{"e", []tsm1.Value{tsm1.NewValue(1, 2.0)}},
		},
		//keyValues{"b", []tsm1.Value{tsm1.NewValue(0, 1.0), tsm1.NewValue(7, 8.0)}},
		//keyValues{"c", []tsm1.Value{tsm1.NewValue(2, 3.0), tsm1.NewValue(3, 4.0)}},
		//keyValues{"d", []tsm1.Value{tsm1.NewValue(4, 5.0), tsm1.NewValue(8, 9.0)}},
		//keyValues{"e", []tsm1.Value{tsm1.NewValue(5, 6.0)}},
	}

	files, err := newFiles(dir, data...)
	if err != nil {
		t.Fatalf("unexpected error creating files: %v", err)
	}

	fs.Replace(nil, files)

	fs.WalkKeys([]byte("d"), func(key []byte, typ byte) error {
		fmt.Println("xxxx | ", string(key[:]))
		return nil
	})

	buf := make([]tsm1.FloatValue, 1000)
	c := fs.KeyCursor(context.Background(), []byte("cpu"), 0, true)
	// Search for an entry that exists in the second file
	values, err := c.ReadFloatBlock(&buf)
	if err != nil {
		t.Fatalf("unexpected error reading values: %v", err)
	}

	//c.Next()
	//values, _ = c.ReadFloatBlock(&buf)
	//c.Next()
	//values, _ = c.ReadFloatBlock(&buf)
	//fmt.Println("values len | ", len(values))
	for _, vv := range values {
		fmt.Println("sss | ", vv.Value())
		//fmt.Println(vv.Value())
	}

	exp := data[0][0]
	if got, exp := len(values), len(exp.values); got != exp {
		t.Fatalf("value length mismatch: got %v, exp %v", got, exp)
	}

	for i, _ := range exp.values {
		//if got, exp := values[i].Value(), v.Value(); got != exp {
		if got, exp := values[i].Value(), 1000.0; got != exp {
			t.Fatalf("read value mismatch(%d): got %v, exp %v", i, got, exp)
		}
	}
}
